## 면접 관련 특강
### 가장 많이 물어보는 자료구조 stack과 queue
나와야 하는 키워드 === 후입선출, 선입선출 

배열과 링크드리스트 === 순차적 연결 공통점, 연속적 연결과 건너건너 연결의 차이
- 까지는 70% 대답
중요한건 어디에 쓰느냐는 것
- 스택은 어디에 쓸까? : 뒤로가기, 계산기, 방문기록 구현 등(스택은 어떻게 구현할지 꼬리질문 대비)
- 큐는 어디에 쓸까? : 줄세우기와 관련된 구현

링크드리스트와 배열의 차이에 주목
- 링크드리스트와 배열의 차이는? 
  - 링크드리스트의 접근은 배열보다 느린가? 네.
	-	링크드리스트의 추가와 삭제는 항상 배열보다 빠른가? 
		-	링크드리스트가 만약 정렬이 되어있다면 x 아니라면 o 
      - 기본적인 답변은 지양하는 것이 좋음

---

### DB 관련 질문 RDB 와 NoSQL 비교

나와야 하는 키워드 === 스키마 유무, 관계정의, 대표적인 아키텍쳐들

하지만 모든 것은 돌고돌아 관련이 되어있음

RDB 는 테이블이라는 곳에 데이터를 저장할 '수 있음'

저장이 가능한 이유는 '데이터 컬럼이 정해져 있기 때문(정돈되고 일관됨)'

정돈되고 일관되었기 때문에 '믿고 관계를 맺는게 가능'

때문에 '정돈'이 되어있는 상태를 유지해야함(트랜잭션)

정돈을 잘 하기 위해 '설계도(스키마)' 가 필요함

때문에 RDB는 스키마가 필요하고, 정규화가 필요하며, 테이블끼리 관계를 맺는것이 중요함. 

---

NoSQL은 정반대로 join과 트랙잭션 같은 기본 기능들을 '없앰' 

왜 없냐면 이걸 없애고 규칙에서 자유로운 유연하고 빠른 설계가 가능해지기 때문

덕분에 저장에 유연성이 더해질 수 있고 속도 또한 '빠름'

join 에 대한 말을 해야할 때 

중요한 키워드는 '합치는 것' 무엇을? 테이블을 합치는 행위를 join

테이블간의 교집합, 합집합 같은 유식한 말을 쓸 수도 있지만 외운 티가 나기에 나만의 정의법을 사용

예시를 들어 설명하면 best!! (학생과 과목)

---

트랜젝션을 설명해야 할 때 

중요한 키워드는 '단위' 그리고 ACID

구현까지 생각하기보단 네 속성의 정의를 잘 알고 외워두는 것! 

개발자라고 외워두고 쓰거나 하진 않음!

독립성에 대한 의문: 독립성이 보장되면 데드락은 발생하지 않게될까? 
- 독립성이 보장되면 데드락이 발생할 확률이 줄게 됨! 
  - 근데 절대 발생하지 않는 것은 아님! orm을 쓸 때나 사용자 인증 과정이나 어떤 때든지 데드락은 발생할 수 있음
  - RDB 에 한정된 생각을 갖지 않을 것 

일관성에 대한 의문: 어디까지 일관되야 하는 것일까? 
- 중요 키워드 '결과' '무결성' 
  - 원자성과의 차이를 알아야 함. 원자성은 어떻게든 '끝까지' 가면 된다
  - 일관성은 '끝난 뒤' 결과가 '무결성을 보장해야한다' 즉 보기에 뭐가 문제가 있어보이면 안된다 정도로 생각

---

primary와 foreign key 를 설명해야 할 때 

primary, 기본 키라는 명칭을 들었을 때 무엇이 떠올라야 하는가? 
- '식별' '대표' '유일'
  - 테이블에서 레코드를 특정할 수 있는 장치
  - 때문에 유일해야하고, null값이 있어서는 안됨으로 설명이 이어질 수 있다. 

foreign, 외래 키라는 명칭을 들었을 때 무엇이 떠올라야 하는가? 
- '관계', '참조', '레퍼런스'
  - 테이블과 테이블의 '관계' 를 맺기 위해 필요한 키
  - 다른 테이블을 '참조' 하기 위해 필요한 키
  - '래퍼런스' 라고도 불리는 키

- foreign key를 사용했을 때 생길 수 있는 이슈 몇가지
  - foreign key를 통해 참조하고 있던 데이터가 삭제된다면 어떻게 동작할까? 
    - 참조할 때 null을 뱉거나 default 설정된 값으로 대체될 것이다. 
    - 예를 들어 설명: 에브리타임은 탈퇴한 유저의 게시물을 삭제하지 않고, 작성자 명만 (알수없음) 으로 표기함! 원래 작성자 명 => (알수 없음) 이라는 default 값으로 변한 것! 

---

Deadlock 을 설명해야 할 때 

삼단 논법으로 기억하자

1. 프로세스는 실행되기 위해서 자원이 필요하다

2. 자원이 선점당했을 경우 프로세스는 기다린다. 

3. 근데 먼저 선점한 프로세스가 기다리는 프로세스의 자원이 필요하다?

서로가 서로를 원해야 하는 상황이 발생! 무한정 교착상태에 놓임.

해결방법과 회피 방법이 있음

해결방법
1. 자원을 공유한다. === 독점하지 못하게 한다. -> 그다지 현실적이지 못함. 하나의 프로세스씩 써야 하는 자원이 분명히 있기 때문
2. deadlock의 형태는 서로, 혹은 원형으로 꼬리물듯 이루어져 있음. 어느 한쪽을 끊거나 원형의 꼬리 중 하나를 끊는다면 예방이 가능!
3. 애초에 자원을 전부 선점하지 못하면 실행하지 못하도록 함

회피방법
1. 교착상태에 놓이면 강력한 관리자가 어느 한 프로세스가 필요한 자원을 가진 다른 프로세스를 모두 종료시킨 뒤 자원을 몰빵해줌
2. 그냥 무시함. 타조 알고리즘이라고 하는데?? 너무 상남자 아닌가


